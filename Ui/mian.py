from PyQt5 import QtCore, QtGui, QtWidgets, uic
from PyQt5.QtCore import QThread, pyqtSignal
import requests
import os
import time
import socket
import struct
import pandas as pd
import time
import os
import psutil
from maincap import NetworkScanner

class NetworkMonitorWorker(QThread):
    update_signal = pyqtSignal(int, int)

    def run(self):
        old_sent, old_recv = self.get_network_usage()
        while True:
            network_stats = psutil.net_io_counters()

            time.sleep(1)
            self.update_signal.emit(
                network_stats.bytes_sent,
                network_stats.bytes_recv
            )
             # Update every second

class WorkerThread1(QThread):
    update_progress_signal = pyqtSignal(int, int, int, float, float)

    def calculate_network_percentage(self, old_sent, old_recv, new_sent, new_recv, interval):
        sent_speed = (new_sent - old_sent) / interval
        recv_speed = (new_recv - old_recv) / interval


        total_speed = sent_speed + recv_speed




        percentage = (total_speed / 1000) * 100



        return percentage

    def get_network_usage(self):
        network_stats = psutil.net_io_counters()
        return network_stats.bytes_sent, network_stats.bytes_recv

    def run(self):
        total_iterations = 100
        j = 0
        old_sent, old_recv = self.get_network_usage()

        while j < total_iterations:
            # Simulating some processing time
            time.sleep(1)
            new_sent, new_recv = self.get_network_usage()
            interval = 1  # seconds


            network_percentage = self.calculate_network_percentage(old_sent, old_recv, new_sent, new_recv, interval)

            # Memory usage
            total_memory = psutil.virtual_memory().total
            used_memory = psutil.virtual_memory().used
            memory_percentage = (used_memory / total_memory) * 100
            m = int(memory_percentage)

            # CPU utilization
            cpu_percent = psutil.cpu_percent(interval=None)
            j = int(cpu_percent)

            # Disk usage
            disk_usage = psutil.disk_usage('/')
            disk_percentage = disk_usage.percent

            # Network speed and usage
            network_stats = psutil.net_io_counters()
            bytes_sent = network_stats.bytes_sent
            bytes_recv = network_stats.bytes_recv

            # Calculate network speed in bytes per second

            # Emit signals to update progress bars
            self.update_progress_signal.emit(j, m, int(disk_percentage), bytes_sent, bytes_recv)
            old_sent, old_recv = new_sent, new_recv


class WorkerThread(QThread):
    update_progress_signal = pyqtSignal(int)

    def run(self):
        total_iterations = 100

        for i in range(total_iterations):
            # Your processing logic here
            time.sleep(0.1)  # Simulating some processing time

            # Emit signal to update progress bar
            self.update_progress_signal.emit(i + 1)
class ScanningThread(QThread):
    scan_completed = pyqtSignal()

    def run(self):

        network_scanner = NetworkScanner()
        network_scanner.start_scanning()

        self.scan_completed.emit()

# Define the VirusTotalChecker class
class VirusTotalChecker:
    def __init__(self, api_key, max_size_kb=2048):
        self.api_key = api_key
        self.max_size_kb = max_size_kb
        self.all_files = {}  # Initialize the dictionary to store information about all files

    def list_and_check_files(self, directory):
        try:
            with os.scandir(directory) as entries:
                for entry in entries:
                    if entry.is_file() and entry.stat().st_size < self.max_size_kb * 1024:
                        file_path = os.path.join(directory, entry.name)
                        print(f"Checking file: {entry.name}")
                        self.check_file_virustotal(file_path)
        except FileNotFoundError:
            print(f"Error: Directory '{directory}' not found.")
        except Exception as e:
            print(f"An error occurred: {e}")

    def check_file_virustotal(self, file_path):
        url = 'https://www.virustotal.com/vtapi/v2/file/scan'
        params = {'apikey': self.api_key}

        with open(file_path, 'rb') as file:
            files = {'file': (file_path, file)}
            response = requests.post(url, files=files, params=params)

        if response.status_code == 200:
            json_response = response.json()
            resource = json_response.get('resource')
            if resource:
                self.check_file_status(resource, file_path)
            else:
                print("Error: Unable to get resource from VirusTotal response.")
        else:
            print(f"Error during file scan: {response.status_code}, {response.text}")
    def check_file_status(self, resource, file_path):
        url = 'https://www.virustotal.com/vtapi/v2/file/report'
        params = {'apikey': self.api_key, 'resource': resource}

        for attempt in range(5):
            response = requests.get(url, params=params)
            time.sleep(6)

            if response.status_code == 200:
                json_response = response.json()
                positives = json_response.get('positives', 0)
                total = json_response.get('total', 0)
                if positives > 0:
                    print(f"The file is malicious! Detection rate: {positives}/{total}")
                    self.all_files[file_path] = (
                        f"{positives}/{total}", "Malicious")  # Store malicious file info in the dictionary
                else:
                    print("The file is not detected as malicious.")
                    self.all_files[file_path] = (
                        f"{positives}/{total}", "Safe")
                    # Store non-malicious file info in the dictionary
                break  # Break out of the retry loop if successful
            elif response.status_code == 204:
                print(f"Report not ready. Retrying in 3 seconds (attempt {attempt + 1}/5)...")
            else:
                print(f"Error: {response.status_code}, {response.text}")
                break  # Break out of the retry loop if an error occurs

# Define the FileCheckThread class
class FileCheckThread(QThread):
    finished_signal = pyqtSignal()

    def __init__(self, directory, api_key, vt_checker):
        super(FileCheckThread, self).__init__()
        self.directory = directory
        self.api_key = api_key
        self.vt_checker = vt_checker

    def run(self):
        self.vt_checker.list_and_check_files(self.directory)
        self.finished_signal.emit()

# Define the Application class
class Application(object):
    def __init__(self, app):
        self.app = app
        self.ui = uic.loadUi("ui_interface.ui")
        self.ui.setWindowTitle("King")


        self.textEdit_2=self.ui.textEdit_2
        self.textEdit_2.setReadOnly(True)
        self.textEdit_2.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)


        self.textEdit_4=self.ui.textEdit_4


        self.textEdit_4.setReadOnly(True)
        self.textEdit_4.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)

        self.progress_bar=self.ui.progressBar_4
        self.vt_checker = VirusTotalChecker(api_key='23543f356239ec05832149afddee451e3c7149ba3eb5e841d70129a8162a88d8')

        # Connect buttons to methods
        self.ui.pushButton_7.clicked.connect(lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.page))
        self.ui.pushButton_4.clicked.connect(lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.page_3))
        self.ui.pushButton_5.clicked.connect(lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.page_2))
        self.ui.toolButton.clicked.connect(lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.page_5))
        self.ui.toolButton_2.clicked.connect(lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.page))
        self.ui.pushButton_2.clicked.connect(lambda:self.ui.stackedWidget.setCurrentWidget(self.ui.page_2))
        self.ui.pushButton_15.clicked.connect(self.start_file_check_thread)
        self.ui.pushButton_16.clicked.connect(self.start_scan)

        self.ui.toolButton_5.clicked.connect(lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.page_3))

        self.ui.pushButton_11.clicked.connect(lambda:self.ui.stackedWidget.setCurrentWidget(self.ui.page_6))
        self.ui.toolButton_3.clicked.connect(lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.page_3))
        self.ui.toolButton_4.clicked.connect(lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.page_3))

        self.start_processing1()
        #
        #self.start_processing2()

        #self.ui.pushButton_15.clicked.connect(self.start_scan)

        self.ui.show()
        self.run()



    def start_file_check_thread(self):
        self.file_check_thread = FileCheckThread(directory='C:/Users/ajay dattu/PycharmProjects/pythonProject/Ui',
                                                 api_key='23543f356239ec05832149afddee451e3c7149ba3eb5e841d70129a8162a88d8',
                                                 vt_checker=self.vt_checker)
        self.progress_bar.setValue(10)
        self.file_check_thread.finished_signal.connect(self.file_check_finished)
        self.file_check_thread.start()

    def file_check_finished(self):
        self.start_processing()
        print("File checking is finished!")


        # Print the information about all files

    def run(self):
        self.app.exec_()

    def start_scan(self):
        self.scanning_thread = ScanningThread()
        self.scanning_thread.scan_completed.connect(self.scan_completed)

        self.scanning_thread.start()

    def scan_completed(self):
        print("Scan completed!")

    def start_processing(self):
        self.worker_thread = WorkerThread()

        # Connect the signal from the worker thread to the update_progress_bar slot
        self.worker_thread.update_progress_signal.connect(self.update_progress_bar)

        # Start the worker thread
        self.worker_thread.start()
    def start_processing1(self):
        self.worker_thread = WorkerThread1()

        # Connect the signal from the worker thread to the update_progress_bar slot
        self.worker_thread.update_progress_signal.connect(self.update_progress_bar1)

        # Start the worker thread
        self.worker_thread.start()
    def start_processing2(self):
        self.worker_thread = NetworkMonitorWorker()
        self.worker_thread.update_signal.connect(self.update_network_usage)
        self.worker_thread.start()

    def update_progress_bar(self, value):
        self.progress_bar.setValue(value)
        if value == 100:
            print("Processing complete!")
            print("All Files:")
            for file_path, (detection_rate, status) in self.vt_checker.all_files.items():
                if "Malicious" in status:
                    self.ui.texteEdit_5.append(f"Malicious item detected in file: {file_path}. Status: {status}")
                    break
                else:
                    self.textEdit_4.append(f"Safe file: {file_path}. Status: {status}")
                print(f"Detection rate: {detection_rate}")
    def update_progress_bar1(self, value,val,va,send,recv):
        self.ui.progressBar.setValue(value)
        self.ui.progressBar_2.setValue(val)
        self.ui.progressBar_5.setValue(va)

        data=f"--{send}"
        self.ui.textEdit.append(data)
        data = f"--{recv}"
        self.ui.textEdit_3.append(data)
        #self.ui.textEdit_2


    def update_network_usage(self, bytes_sent, bytes_recv):
        text = f"-->Bytes sent: {bytes_sent} Bytes_recv\n"
        print(text)
        self.ui.textEdit.append(text)



if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    application = Application(app)

    # Consider moving sys.exit(app.exec_()) outside this block
    # to allow cleaner handling of exceptions for debugging.
    try:
        sys.exit(app.exec_())
    except Exception as e:
        print(f"An error occurred: {e}")