import socket
import struct
import pandas as pd
import time
import os
import sys
from sklearn.ensemble import RandomForestClassifier
import textwrap

start_time = time.time()


# Assuming the target column is named "target" (adjust as per your data)

class NetworkScanner:
    def __init__(self,a):
        self.conn = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(3))
        self.start_time = time.time()
        self.a=""

    @staticmethod
    def ethernet_frame(data):
        dest_mac, src_mac, proto = struct.unpack("! 6s 6s H", data[:14])
        return NetworkScanner.get_mac_addr(dest_mac), NetworkScanner.get_mac_addr(src_mac), socket.htons(proto), data[
                                                                                                                 14:]

    @staticmethod
    def get_mac_addr(bytes_addr):
        bytes_str = map('{:02x}'.format, bytes_addr)
        return ':'.join(bytes_str).upper()

    @staticmethod
    def ipv4_packet(data):
        version_header_length = data[0]
        version = version_header_length >> 4
        header_length = (version_header_length & 15) * 4
        ttl, proto, src, target = struct.unpack('! 8x B B 2x 4s 4s', data[:20])
        return version, header_length, ttl, proto, NetworkScanner.ipv4(src), NetworkScanner.ipv4(target), data[
                                                                                                          header_length:]

    @staticmethod
    def ipv4(addr):
        return '.'.join(map(str, addr))

    @staticmethod
    def icmp_packet(data):
        icmp_type, code, checksum = struct.unpack("! B B H", data[:4])
        return icmp_type, code, checksum, data[4:]

    @staticmethod
    def tcp_packet(data):
        src_port, dest_port, sequence, acknowledgement, offset_reserved_flags = struct.unpack('! H H L L H', data[:14])
        offset = (offset_reserved_flags >> 12) * 4
        flag_urg = (offset_reserved_flags & 32) >> 5
        flag_ack = (offset_reserved_flags & 16) >> 4
        flag_psh = (offset_reserved_flags & 8) >> 3
        flag_rst = (offset_reserved_flags & 4) >> 2
        flag_syn = (offset_reserved_flags & 2) >> 1
        flag_fin = (offset_reserved_flags) & 1
        return src_port, dest_port, sequence, acknowledgement, flag_urg, flag_ack, flag_psh, flag_rst, flag_syn, flag_fin, data[
                                                                                                                           offset:]

    @staticmethod
    def udp_segment(data):
        src_port, dest_port, size = struct.unpack('! H H 2x H', data[:8])
        return src_port, dest_port, size, data[8:]

    @staticmethod
    def arp_packet(data):
        arp_hw_type, arp_proto_type, arp_hw_size, arp_proto_size, arp_opcode, arp_sender_mac, arp_sender_ip, arp_target_mac, arp_target_ip = struct.unpack(
            '! H H B B H 6s 4s 6s 4s', data[:28])
        return arp_hw_type, arp_proto_type, arp_hw_size, arp_proto_size, arp_opcode, NetworkScanner.get_mac_addr(
            arp_sender_mac), NetworkScanner.ipv4(arp_sender_ip), NetworkScanner.get_mac_addr(
            arp_target_mac), NetworkScanner.ipv4(arp_target_ip), data[28:]

    def format_multi_line(self, prefix, string, size=80):
        size -= len(prefix)
        if isinstance(string, bytes):
            string = ''.join(r'\x{:02x}'.format(byte) for byte in string)
            if size % 2:
                size -= 1
            return '\n'.join([prefix + line for line in textwrap.wrap(string, size)])

    def read_csv(self, file_path="samds.csv"):
        return pd.read_csv(file_path)

    def main(self):
        print("hello")
        count = 0
        sessions = {}
        sessions2 = {}

        while True:
            raw_data, addr = self.conn.recvfrom(65536)
            print("hello")
            dest_mac, src_mac, eth_protoc, data = self.ethernet_frame(raw_data)
            if time.time() - self.start_time >= 10:
                if count > 0:
                    a="\nSuspicious network activity detected! at 10.0.2.15"
                    break
                else:
                    a="\nNetwork is Clear"
                    break

            src_port, dest_port, sequence, acknowledgement, flag_urg, flag_ack, flag_psh, flag_rst, flag_syn, flag_fin, icmp_type, code, proto = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

            session_data = {
                "DestMac": 0,
                "SrcMac": 0,
                "EthProtocol": 0,
                "Version": 0,
                "TTL": 0,
                "Proto": 0,
                "SrcIP": 0,
                "DestIP": 0,
                "ICMPType": 0,
                "ICMPCode": 0,
                "TCPSourcePort": 0,
                "TCPDestPort": 0,
                "TCPSequence": 0,
                "TCPAcknowledgement": 0,
                "FlagURG": 0,
                "FlagACK": 0,
                "FlagPSH": 0,
                "FlagRST": 0,
                "FlagSYN": 0,
                "FlagFIN": 0,
                "UDPSrcPort": 0,
                "UDPDestPort": 0,
                "UDPLength": 0,
                "Duration": 0,
                "ARP_HW_Type": 0,
                "ARP_Proto_Type": 0,
                "ARP_Opcode": 0,
            }

            if eth_protoc == 8:
                version, header_length, ttl, proto, src, target, data = self.ipv4_packet(data)

                if proto == 1:
                    icmp_type, code, checksum, data = self.icmp_packet(data)

                elif proto == 6:
                    src_port, dest_port, sequence, acknowledgement, flag_urg, flag_ack, flag_psh, flag_rst, flag_syn, flag_fin, data = self.tcp_packet(
                        data)

                elif proto == 17:
                    src_port, dest_port, length, data = self.udp_segment(data)

                else:
                    continue

                session_key = f"{src}:{src_port}{target}:{dest_port}{proto}"
                if session_key not in sessions:
                    sessions[session_key] = {'start_time': time.time()}

                duration = time.time() - sessions[session_key].get('start_time', time.time())

                session_data.update({
                    "DestMac": dest_mac,
                    "SrcMac": src_mac,
                    "EthProtocol": eth_protoc,
                    "Version": version,
                    "TTL": ttl,
                    "Proto": proto,
                    "SrcIP": src,
                    "DestIP": target,
                    "ICMPType": icmp_type if proto == 1 else 0,
                    "ICMPCode": code if proto == 1 else 0,
                    "TCPSourcePort": src_port if proto == 6 else 0,
                    "TCPDestPort": dest_port if proto == 6 else 0,
                    "TCPSequence": sequence if proto == 6 else 0,
                    "TCPAcknowledgement": acknowledgement if proto == 6 else 0,
                    "FlagURG": flag_urg if proto == 6 else 0,
                    "FlagACK": flag_ack if proto == 6 else 0,
                    "FlagPSH": flag_psh if proto == 6 else 0,
                    "FlagRST": flag_rst if proto == 6 else 0,
                    "FlagSYN": flag_syn if proto == 6 else 0,
                    "FlagFIN": flag_fin if proto == 6 else 0,
                    "UDPSrcPort": src_port if proto == 17 else 0,
                    "UDPDestPort": dest_port if proto == 17 else 0,
                    "UDPLength": length if proto == 17 else 0,
                    "Duration": duration
                })
                if src == '10.0.2.10' or target == '10.0.2.10':
                    values_only = list(session_data.values())
                    column_names = list(session_data.keys())

                    df = pd.DataFrame([values_only]).reset_index(drop=True)
                    df.columns = column_names
                    print(df)
                    '''prediction = self.my_classification_predict(df)
                    print(prediction)
                    if prediction[0] == 'suspicious':
                        count += 1'''
            elif eth_protoc == 1544:
                arp_hw_type, arp_proto_type, arp_hw_size, arp_proto_size, arp_opcode, arp_sender_mac, arp_sender_ip, arp_target_mac, arp_target_ip, data = self.arp_packet(
                    data)

                arp_src_mac = NetworkScanner.get_mac_addr(arp_sender_mac)
                arp_dest_mac = NetworkScanner.get_mac_addr(arp_target_mac)

                arp_src_ip = NetworkScanner.ipv4(arp_sender_ip)
                arp_dest_ip = NetworkScanner.ipv4(arp_target_ip)
                session_key = f"{arp_src_ip}_{arp_dest_ip}"

                if session_key not in sessions2:
                    sessions2[session_key] = {'start_time': time.time()}
                duration2 = time.time() - sessions2[session_key].get('start_time', time.time())

                session_data.update({
                    "DestMac": arp_dest_mac,
                    "SrcMac": arp_src_mac,
                    "EthProtocol": eth_protoc,
                    "Version": version if eth_protoc == 8 else 0,
                    "TTL": ttl if eth_protoc == 8 else 0,
                    "Proto": proto if eth_protoc == 8 else 0,
                    "SrcIP": src if eth_protoc == 8 else arp_src_ip,
                    "DestIP": target if eth_protoc == 8 else arp_dest_ip,
                    "ICMPType": icmp_type if proto == 1 else 0,
                    "ICMPCode": code if proto == 1 else 0,
                    "TCPSourcePort": src_port if proto == 6 else 0,
                    "TCPDestPort": dest_port if proto == 6 else 0,
                    "TCPSequence": sequence if proto == 6 else 0,
                    "TCPAcknowledgement": acknowledgement if proto == 6 else 0,
                    "FlagURG": flag_urg if proto == 6 else 0,
                    "FlagACK": flag_ack if proto == 6 else 0,
                    "FlagPSH": flag_psh if proto == 6 else 0,
                    "FlagRST": flag_rst if proto == 6 else 0,
                    "FlagSYN": flag_syn if proto == 6 else 0,
                    "FlagFIN": flag_fin if proto == 6 else 0,
                    "UDPSrcPort": src_port if proto == 17 else 0,
                    "UDPDestPort": dest_port if proto == 17 else 0,
                    "UDPLength": length if proto == 17 else 0,
                    "Duration": duration2,
                    "ARP_HW_Type": arp_hw_type,
                    "ARP_Proto_Type": arp_proto_type,
                    "ARP_Opcode": arp_opcode,
                })

                if True:  # Add your condition here
                    values_only = list(session_data.values())
                    df = pd.DataFrame([values_only]).reset_index(drop=True)
                    column_names = list(session_data.keys())
                    df.columns = column_names
                    # prediction = self.my_classification_predict(df)

                    '''if prediction[0] == "suspicious":
                        count += 1'''

            else:
                continue

    def start_scanning(self):
        self.main()


if __name__ == "__main__":
    network_scanner = NetworkScanner(vt_checker=a)
    network_scanner.start_scanning()